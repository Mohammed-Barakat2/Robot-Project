from roboticstoolbox import Bicycle, RandomPath, VehicleIcon, RangeBearingSensor,LandmarkMap
from math import pi, atan2
import matplotlib.pyplot as plt

#User inputs for starting robot position (x,y,z), number of randomly generated obsticles, and the goal position.
a1 = int(input('Please provide the starting x-coordinate:'))
b1 = int(input('Please provide the starting y-coordinate:'))
c1 = int(input('Please provide the starting z-coordinate:'))
d1 = int(input('Please provide the number of obstacles:'))
a2 = int(input('Please provide the target x-coordinate:'))
b2 = int(input('Please provide the target y-coordinate:'))

#
anim = VehicleIcon('Robot.png', scale = 2)
veh = Bicycle(
 animation=anim,
 control=RandomPath,
 x0=(a1,b1,c1),
)
veh.init(plot=True)

#Randomly placed obsticles on a 20 by 20 grid
map = LandmarkMap(d1,20)
map.plot()

#Goal code
goal=[a2,b2]; 
goal_marker_style = {
 'marker': 'D',
 'markersize': 6,
 'color': 'b',
}
plt.plot(goal[0], goal[1], **goal_marker_style)


sensor=RangeBearingSensor(robot=veh, map= map ,animate=True)


run =True
while(run):
 goal_heading = atan2(
 goal[1] - veh.x[1],
 goal[0] - veh.x[0]
 )
 steer = goal_heading-veh.x[2]
 veh.step(2,steer)
 if( (abs(goal[0]-veh.x[0]) > 0.3) or (abs(goal[1]-veh.x[1]) >
 0.3) ):
    run=True
 else:
    run =False
 veh._animation.update(veh.x)
 plt.pause(0.0005)

veh._animation.update(veh.x)
plt.pause(1000)
